"1. Написать функцию, вычисляющую НОД двух чисел (или многочленов)"

function gcd_(a::T, b::T) where T # - это означает, что тип обоих аргументов один и тот же
    # a0, b0 = a, b
    #ИНВАРИАНТ: НОД(a,b) = HОД(a0,b0)
    while !iszero(b) # - это условие более универсальное, чем b != 0 или b > 0. Функция iszero определена для всех числовых типов. Для пользовательских типов ее надо будет определять
        a, b = b, rem(a,b) # rem(a,b) - это то же самое, что и a % b (есть еще функция mod(a,b))
    end
    return abs(a) # т.к. используется функция rem, то a может получиться отризательным
end


"2. Написать функцию, реализующую расширенный алгоритм Евклида, вычисляющий не только НОД, но и коэффициенты его линейного представления.

**Утверждение.** Пусть d=НОД(a, b), тогда существуют такие целые коэффициенты u, v, что d=u*a+v*b

Мы спроектируем расширенный алгоритм Евклида с помощью инварианта цикла, и тем самым будет доказаго это утверждение.

Напомним, что инвариантом цикла (с передусловием) называется некотрое утверждение относительно переменных, изменяющихся в цикле, которое справедливо как перед началом выполнения цикла, так и после любого числа его повторений.

В данном случае в качестве инварианта цикла возьмём утверждение "


function gcdx_(a::T, b::T) where T # - это означает, что тип обоих аргументов один и тот же
    # a0, b0 = a, b
    u, v = one(T), zero(T) # - универсальнее, чем 1, 0 и гарантирует стабильность типов переменных
    u_, v_ = v, u
    #ИНВАРИАНТ: НОД(a,b) = HОД(a0,b0) && a = u*a0 + v*b0 && b = u_*a0 + v_ * b0
    while !iszero(b) # - это условие более универсальное, чем b != 0 или b > 0. Функция iszero определена для всех числовых типов. Для пользовательских типов ее надо будет определять
        r, k = rem(a, b), div(a, b) # remdiv(a,b) возвращает кортеж из rem(a,b) и div(a,b)
        a, b = b, r #  r = a - k*b
        u, u_ = u_, u-k*u_ # эти преобразования переменных следуют из инварианта цикла
        v, v_ = v_, v-k*v_
    end
    if isnegative(a) #  использование функции isnegative делает данный алгоритм более универсальным, но эту функцию требуется определить, в том числе и для целых типов
        a, u, v = -a, -u, -v
    end
    return a, u, v #a, x, y
end
#в итоге a - НОД(a, b)
isnegative(a::Integer) = (a < 0)

"3. С использованием функции gcdx_ реаализовать функцию invmod_(a::T, M::T) where T, которая бы возвращала бы обратное значение инвертируемого элемента (a) кольца вычетов по модулю M, а для необращаемых элементов возвращала бы nothing.

(если положить M=b  и если d = ua+vb, то при условии, что d=1, a^-1 = u, в противном случае элемент a не обратим)"

function invmod_(a::T, M::T) where T
    if gcd_(a, M) == 1
        g = gcdx_(a, M)
        return g[2]
    end
    return nothing
end


"4. С использованием функции gcdx_ реализовать функцию diaphant_solve(a::T,b::T,c::T) where T, которая бы возвращала решение дафаетового уравнения ax+by=c, если уравнение разрешимо, и значение nothing - в противном случае
   
(если d=ua+vb, и если получилость, что d=1, u, v - есть решение уравнения, в противном случае уранение не разрешимо)"

function diaphant_solve(a::T, b::T, c::T) where T
    d = gcd(a, b)
    if c % d != 0
        return nothing
    end
    t, u, v = gcdx_(a, b)
    c /= d
    u0, v0 = u*c, v*c
    return u0, b/d, v0, a/d # x = u0 + b/d; y = v0 - a/d 
end
print(diaphant_solve(3, 4, 5))